// Core type definitions for Elizabeth platform

// Import auto-generated types from Rust backend
// These types are automatically generated by ts-rs during build
// To regenerate: cargo build --package elizabeth-board --features typescript-export
export * from '../types/generated/api.types';

// ============================================================================
// Backend API Types (aligned with Rust backend)
// ============================================================================

/**
 * Content Type enumeration (matches backend ContentType enum)
 */
export enum ContentType {
  Text = 0,
  Image = 1,
  File = 2,
  Url = 3,
}

/**
 * Backend ContentType response format (tagged enum)
 */
export type BackendContentType =
  | { type: "text" }
  | { type: "image" }
  | { type: "file" }
  | { type: "url" };

/**
 * Convert backend ContentType to frontend enum
 */
export function parseContentType(
  backendType: BackendContentType | number | undefined | null,
): ContentType {
  // Fallback when backend omits content_type (e.g., during upload pipeline)
  if (backendType == null) {
    return ContentType.File;
  }
  if (typeof backendType === "number") {
    return backendType as ContentType;
  }

  const typeMap: Record<string, ContentType> = {
    text: ContentType.Text,
    image: ContentType.Image,
    file: ContentType.File,
    url: ContentType.Url,
  };

  return typeMap[backendType.type] ?? ContentType.File;
}

/**
 * Room permission bits (backend uses bitflags)
 * - READ = 1
 * - EDIT = 2
 * - SHARE = 4
 * - DELETE = 8
 */
export type RoomPermission = "read" | "edit" | "share" | "delete";

/**
 * Backend Room response
 */
export interface BackendRoom {
  id?: number;
  name: string;
  slug: string;
  password: string | null; // Room password (null if no password)
  permission: number | string; // Bitflags: 1=read, 2=edit, 4=share, 8=delete, or string representation
  status: "open" | "lock" | "close";
  max_size: number;
  current_size: number;
  max_times_entered: number;
  current_times_entered: number;
  created_at: string;
  updated_at: string;
  expire_at: string | null;
}

/**
 * Backend RoomContent response
 */
export interface BackendRoomContent {
  id: number;
  content_type: BackendContentType | number;
  file_name?: string;
  url?: string | null;
  size?: number;
  mime_type?: string;
  text?: string;
  created_at: string;
  updated_at: string;
}

/**
 * Upload preparation response
 */
export interface UploadPreparationResponse {
  reservation_id: number;
  reserved_size: number;
  expires_at: string;
  current_size: number;
  remaining_size: number;
  max_size: number;
}

/**
 * Backend Token response
 */
export interface BackendTokenResponse {
  token: string;
  claims: {
    sub: string;
    room_id: number;
    room_name: string;
    permission: number;
    max_size: number;
    exp: number;
    iat: number;
    jti: string;
    token_type: "access" | "refresh";
    refresh_jti?: string;
  };
  expires_at: string;
  refresh_token?: string;
  refresh_token_expires_at?: string;
}

/**
 * Backend Token validation response
 */
export interface BackendTokenValidation {
  claims: {
    sub: string;
    room_id: number;
    room_name: string;
    permission: number;
    max_size: number;
    exp: number;
    iat: number;
    jti: string;
    token_type: "access" | "refresh";
  };
}

// ============================================================================
// Frontend Types
// ============================================================================

export interface RoomSettings {
  expiresAt: string | null;
  passwordProtected: boolean;
  password?: string;
  maxViews: number;
}

export interface RoomDetails {
  id: string;
  name: string;
  slug?: string; // Room slug (name for shareable, name_uuid for non-shareable)
  currentSize: number; // in bytes
  maxSize: number; // in bytes
  timesEntered: number;
  maxTimesEntered: number;
  settings: RoomSettings;
  permissions: RoomPermission[];
  createdAt: string;
  password?: string | null; // Room password (for display in settings)
}

export interface Message {
  id: string;
  content: string;
  timestamp: string;
  fileName?: string;
  user?: string;
  isOwn?: boolean;
  isNew?: boolean;
  isDirty?: boolean;
  isPendingDelete?: boolean;
  originalContent?: string;
}

export type LocalMessage = Message;

export interface FileItem {
  id: string;
  name: string;
  thumbnailUrl: string | null;
  size?: number; // in bytes
  type?: "image" | "video" | "pdf" | "link" | "document";
  url?: string;
  mimeType?: string;
  createdAt?: string;
  uploadedAt?: string;
}

/**
 * Token information stored in localStorage
 */
export interface TokenInfo {
  token: string;
  expiresAt: string;
  refreshToken?: string;
}

/**
 * Token storage format (maps room name to token info)
 */
export type TokenStorage = Record<string, TokenInfo>;

export type Theme = "dark" | "light" | "system";

// ============================================================================
// Permission Utilities
// ============================================================================

/**
 * Convert backend permission bits to frontend permission strings
 */
export function parsePermissions(bits: number | string): RoomPermission[] {
  // Handle string representation (e.g., "VIEW_ONLY | EDITABLE | SHARE | DELETE")
  if (typeof bits === "string") {
    const perms: RoomPermission[] = [];
    if (bits.includes("VIEW_ONLY") || bits.includes("1")) perms.push("read");
    if (bits.includes("EDITABLE") || bits.includes("2")) perms.push("edit");
    if (bits.includes("SHARE") || bits.includes("4")) perms.push("share");
    if (bits.includes("DELETE") || bits.includes("8")) perms.push("delete");
    return perms;
  }

  // Handle numeric bit flags
  const perms: RoomPermission[] = [];
  if (bits & 1) perms.push("read");
  if (bits & 2) perms.push("edit");
  if (bits & 4) perms.push("share");
  if (bits & 8) perms.push("delete");
  return perms;
}

/**
 * Convert frontend permission strings to backend permission bits
 */
export function encodePermissions(perms: RoomPermission[]): number {
  let bits = 0;
  if (perms.includes("read")) bits |= 1;
  if (perms.includes("edit")) bits |= 2;
  if (perms.includes("share")) bits |= 4;
  if (perms.includes("delete")) bits |= 8;
  return bits;
}

/**
 * Convert backend Room to frontend RoomDetails
 */
export function backendRoomToRoomDetails(room: BackendRoom): RoomDetails {
  return {
    id: room.name,
    name: room.name,
    slug: room.slug,
    currentSize: room.current_size,
    maxSize: room.max_size,
    timesEntered: room.current_times_entered,
    maxTimesEntered: room.max_times_entered,
    settings: {
      expiresAt: room.expire_at,
      passwordProtected: room.password !== null && room.password !== "",
      password: room.password ?? undefined,
      maxViews: room.max_times_entered,
    },
    permissions: parsePermissions(room.permission),
    createdAt: room.created_at,
    password: room.password,
  };
}

/**
 * Convert backend RoomContent to frontend Message (for text content)
 */
export function backendContentToMessage(content: BackendRoomContent): Message {
  // Ensure content.text is always a string
  let messageContent = "";
  if (content.text !== undefined && content.text !== null) {
    messageContent = typeof content.text === "string"
      ? content.text
      : String(content.text);
  }

  return {
    id: String(content.id),
    content: messageContent,
    timestamp: content.created_at,
    fileName: content.file_name || undefined,
  };
}

/**
 * Convert backend RoomContent to frontend FileItem (for file content)
 */
export function backendContentToFileItem(
  content: BackendRoomContent,
  roomName?: string,
): FileItem {
  // Be defensive: some responses may not include content_type immediately
  const rawType = (content as any).content_type ?? (content as any).contentType;
  const contentType = parseContentType(rawType);

  const typeMap: Record<number, FileItem["type"]> = {
    [ContentType.Image]: "image",
    [ContentType.File]: "document",
    [ContentType.Url]: "link",
  };

  // âœ… FIX: Generate download URL for file content
  // For file/image content, we need to construct the download URL
  // For URL content, use the stored URL directly
  let fileUrl = content.url;
  if (
    !fileUrl && roomName &&
    (contentType === ContentType.File || contentType === ContentType.Image)
  ) {
    // Construct download URL: /rooms/{roomName}/contents/{contentId}
    // The API client will add the base URL and token
    fileUrl = `/rooms/${roomName}/contents/${content.id}`;
  }

  return {
    id: String(content.id),
    name: content.file_name || "Unnamed",
    thumbnailUrl: null, // Backend doesn't provide thumbnails
    size: content.size || undefined,
    type: typeMap[contentType],
    url: fileUrl ?? undefined,
    mimeType: content.mime_type || undefined,
    createdAt: content.created_at,
    uploadedAt: content.created_at,
  };
}
