pub fn main() {
    println!("cargo:rerun-if-env-changed=DYNAMIC");
    if std::env::var("DYNAMIC").is_ok() {
        println!("cargo:rustc-cfg=feature=\"dynamic\"");
    }

    let denied_consts = [
        "CARGO_MANIFEST_DIR",
        "PROJECT_NAME",
        "CARGO_TREE",
        "GIT_STATUS_FILE",
        "BUILD_TARGET_ARCH",
        "COMMIT_EMAIL",
        "COMMIT_AUTHOR",
        "COMMIT_DATE_2822",
        "COMMIT_DATE",
        "CLAP_LONG_VERSION",
        "BUILD_TIME_2822",
    ];

    use shadow_rs::ShadowBuilder;
    ShadowBuilder::builder()
        .deny_const(denied_consts.into())
        .build()
        .unwrap();

    println!("cargo:rerun-if-changed=.git/HEAD");
    println!("cargo:rerun-if-changed=.git/refs/heads");

    // 生成补全
    #[cfg(feature = "completions")]
    {
        // 生成补全脚本
        if let Err(e) = generate_completions() {
            eprintln!("Failed to generate completions: {}", e);
        }
    }

    // 生成 TypeScript 类型定义
    #[cfg(feature = "typescript-export")]
    {
        if let Err(e) = generate_typescript() {
            eprintln!("Failed to generate TypeScript types: {}", e);
        }
    }
}

// 包含 CLI 定义
#[cfg(feature = "completions")]
include!("src/cmd/cli.rs");

/// 生成补全脚本
#[cfg(feature = "completions")]
fn generate_completions() -> anyhow::Result<()> {
    use clap::{CommandFactory, ValueEnum};
    use clap_complete::Shell;
    use std::env;
    use std::fs::{self, File};
    use std::io::Write;
    use std::path::Path;

    let outdir = env::var_os("OUT_DIR")
        .ok_or("OUT_DIR not set")
        .map_err(|e| anyhow::anyhow!("Failed to get OUT_DIR: {}", e))?;
    let outdir_path = Path::new(&outdir);

    let app_name = env!("CARGO_PKG_NAME");

    let completions_dir = outdir_path.join("completions");
    fs::create_dir_all(&completions_dir)?;

    let completions_rs = outdir_path.join("completions.rs");
    let mut file = File::create(&completions_rs)?;

    writeln!(file, "// Generated shell completions")?;
    writeln!(file, "// This file is automatically generated by build.rs")?;
    writeln!(file, "// Do not edit this file manually")?;
    writeln!(file)?;

    for &shell in Shell::value_variants() {
        let shell_name = match shell {
            Shell::Bash => "bash",
            Shell::Elvish => "elvish",
            Shell::Fish => "fish",
            Shell::PowerShell => "powershell",
            Shell::Zsh => "zsh",
            _ => "bash",
        };

        let mut cmd = Cli::command();

        let file_path = clap_complete::generate_to(shell, &mut cmd, app_name, &completions_dir)?;

        let content = fs::read_to_string(&file_path)?;

        writeln!(file, "/// Completion script for {}", shell_name)?;
        writeln!(
            file,
            "pub const {}_COMPLETION: &str = r#\"{}\"#;",
            shell_name.to_uppercase(),
            content
        )?;
        writeln!(file)?;
    }

    Ok(())
}

/// 生成 TypeScript 类型定义
#[cfg(feature = "typescript-export")]
fn generate_typescript() -> anyhow::Result<()> {
    use std::env;
    use std::fs;
    use std::path::Path;

    // 获取工作区根目录（elizabeth 项目根目录）
    let workspace_dir = env::var("CARGO_MANIFEST_DIR")?;
    let workspace_root = Path::new(&workspace_dir)
        .parent()
        .ok_or_else(|| anyhow::anyhow!("Failed to get workspace root"))?;

    // 输出目录：web/types/generated/
    let output_dir = workspace_root.join("web/types/generated");
    fs::create_dir_all(&output_dir)?;

    // 输出文件路径
    let output_file = output_dir.join("api.types.ts");

    // 生成 TypeScript 类型
    // 注意：这里使用 ts-rs 的导出功能
    // 实际的类型导出会在编译时通过 #[ts(export)] 属性自动完成
    // 这个函数主要用于设置输出目录和触发生成

    // 设置 ts-rs 输出目录
    let out_dir = output_dir.to_string_lossy().to_string();
    unsafe { env::set_var("TS_RS_EXPORT_DIR", &out_dir) };

    // 创建文件头部注释
    let header = r#"// Auto-generated TypeScript types from Rust backend
// This file is automatically generated by ts-rs
// DO NOT EDIT THIS FILE MANUALLY

"#;

    fs::write(&output_file, header)?;

    // 通知 cargo 在以下文件变化时重新运行
    println!("cargo:rerun-if-changed=src/types/mod.rs");
    println!("cargo:rerun-if-changed=src/models/room/mod.rs");
    println!("cargo:rerun-if-changed=src/models/room/content.rs");
    println!("cargo:rerun-if-changed=src/models/room/chunk_upload.rs");
    println!("cargo:rerun-if-changed=src/models/room/refresh_token.rs");
    println!("cargo:rerun-if-changed=src/models/room/upload_reservation.rs");
    println!("cargo:rerun-if-changed=src/models/room/token.rs");

    Ok(())
}
