pub fn main() {
    println!("cargo:rerun-if-env-changed=DYNAMIC");
    if std::env::var("DYNAMIC").is_ok() {
        println!("cargo:rustc-cfg=feature=\"dynamic\"");
    }

    let denied_consts = [
        "CARGO_MANIFEST_DIR",
        "PROJECT_NAME",
        "CARGO_TREE",
        "GIT_STATUS_FILE",
        "BUILD_TARGET_ARCH",
        "COMMIT_EMAIL",
        "COMMIT_AUTHOR",
        "COMMIT_DATE_2822",
        "COMMIT_DATE",
        "CLAP_LONG_VERSION",
        "BUILD_TIME_2822",
    ];

    use shadow_rs::ShadowBuilder;
    ShadowBuilder::builder()
        .deny_const(denied_consts.into())
        .build()
        .unwrap();

    println!("cargo:rerun-if-changed=.git/HEAD");
    println!("cargo:rerun-if-changed=.git/refs/heads");

    // 生成补全
    #[cfg(feature = "completions")]
    {
        // 生成补全脚本
        if let Err(e) = generate_completions() {
            eprintln!("Failed to generate completions: {}", e);
        }
    }

    // 生成 TypeScript 类型定义
    #[cfg(feature = "typescript-export")]
    {
        if let Err(e) = generate_frontend_bindings() {
            eprintln!("Failed to generate frontend bindings: {}", e);
        }
    }
}

// 包含 CLI 定义
#[cfg(feature = "completions")]
include!("src/cmd/cli.rs");

/// 生成补全脚本
#[cfg(feature = "completions")]
fn generate_completions() -> anyhow::Result<()> {
    use clap::{CommandFactory, ValueEnum};
    use clap_complete::Shell;
    use std::env;
    use std::fs::{self, File};
    use std::io::Write;
    use std::path::Path;

    let outdir = env::var_os("OUT_DIR")
        .ok_or("OUT_DIR not set")
        .map_err(|e| anyhow::anyhow!("Failed to get OUT_DIR: {}", e))?;
    let outdir_path = Path::new(&outdir);

    let app_name = env!("CARGO_PKG_NAME");

    let completions_dir = outdir_path.join("completions");
    fs::create_dir_all(&completions_dir)?;

    let completions_rs = outdir_path.join("completions.rs");
    let mut file = File::create(&completions_rs)?;

    writeln!(file, "// Generated shell completions")?;
    writeln!(file, "// This file is automatically generated by build.rs")?;
    writeln!(file, "// Do not edit this file manually")?;
    writeln!(file)?;

    for &shell in Shell::value_variants() {
        let shell_name = match shell {
            Shell::Bash => "bash",
            Shell::Elvish => "elvish",
            Shell::Fish => "fish",
            Shell::PowerShell => "powershell",
            Shell::Zsh => "zsh",
            _ => "bash",
        };

        let mut cmd = Cli::command();

        let file_path = clap_complete::generate_to(shell, &mut cmd, app_name, &completions_dir)?;

        let content = fs::read_to_string(&file_path)?;

        writeln!(file, "/// Completion script for {}", shell_name)?;
        writeln!(
            file,
            "pub const {}_COMPLETION: &str = r#\"{}\"#;",
            shell_name.to_uppercase(),
            content
        )?;
        writeln!(file)?;
    }

    Ok(())
}

/// 生成 TypeScript 类型定义
#[cfg(feature = "typescript-export")]
fn generate_frontend_bindings() -> anyhow::Result<()> {
    use std::env;
    use std::fs;
    use std::path::PathBuf;

    // 获取工作区根目录（elizabeth 项目根目录）
    let manifest_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR")?);
    let workspace_root = manifest_dir
        .parent()
        .and_then(|p| p.parent())
        .ok_or_else(|| anyhow::anyhow!("Failed to get workspace root"))?;

    // 输出目录：web/types/generated/
    let output_dir = workspace_root.join("web/types/generated");
    fs::create_dir_all(&output_dir)?;

    // 清理旧的生成产物（避免删除类型后残留旧文件）
    clean_generated_dir(&output_dir)?;

    // 生成 ts-rs types
    board_protocol::codegen::export_ts_types_to(&output_dir)?;

    // 写入入口文件（前端从这里 import）
    write_ts_index(&output_dir)?;

    // 生成 JSON Schema（供前端消费）
    let schema_json = board_protocol::codegen::api_schema_json_pretty()?;
    let schema_path = output_dir.join("api.schema.json");
    fs::write(&schema_path, schema_json)?;

    println!(
        "cargo:warning=generated TypeScript types into {:?}",
        &output_dir
    );
    println!(
        "cargo:warning=generated JSON schema into {:?}",
        &schema_path
    );

    // 通知 cargo 在以下文件变化时重新运行
    println!("cargo:rerun-if-changed=../board-protocol/src/constants.rs");
    println!("cargo:rerun-if-changed=../board-protocol/src/codegen.rs");
    println!("cargo:rerun-if-changed=../board-protocol/src/dto/mod.rs");
    println!("cargo:rerun-if-changed=../board-protocol/src/dto/token.rs");
    println!("cargo:rerun-if-changed=../board-protocol/src/dto/rooms.rs");
    println!("cargo:rerun-if-changed=../board-protocol/src/dto/content.rs");
    println!("cargo:rerun-if-changed=../board-protocol/src/dto/chunked_upload.rs");
    println!("cargo:rerun-if-changed=../board-protocol/src/dto/auth.rs");
    println!("cargo:rerun-if-changed=../board-protocol/src/models/mod.rs");
    println!("cargo:rerun-if-changed=../board-protocol/src/models/room/mod.rs");
    println!("cargo:rerun-if-changed=../board-protocol/src/models/room/content.rs");
    println!("cargo:rerun-if-changed=../board-protocol/src/models/room/chunk_upload.rs");
    println!("cargo:rerun-if-changed=../board-protocol/src/models/room/permission.rs");
    println!("cargo:rerun-if-changed=../board-protocol/src/models/room/refresh_token.rs");
    println!("cargo:rerun-if-changed=../board-protocol/src/models/room/token.rs");
    println!("cargo:rerun-if-changed=../board-protocol/src/models/room/upload_reservation.rs");

    Ok(())
}

#[cfg(feature = "typescript-export")]
fn clean_generated_dir(dir: &std::path::Path) -> anyhow::Result<()> {
    use std::fs;

    if !dir.exists() {
        return Ok(());
    }

    for entry in fs::read_dir(dir)? {
        let entry = entry?;
        let path = entry.path();
        if !path.is_file() {
            continue;
        }
        let Some(ext) = path.extension().and_then(|s| s.to_str()) else {
            continue;
        };
        if matches!(ext, "ts" | "json") {
            fs::remove_file(&path)?;
        }
    }

    Ok(())
}

#[cfg(feature = "typescript-export")]
fn write_ts_index(output_dir: &std::path::Path) -> anyhow::Result<()> {
    use std::fs;

    let index_file = output_dir.join("api.types.ts");
    let mut content = String::new();
    content.push_str("// Auto-generated TypeScript types from Rust backend\n");
    content.push_str("// This file is automatically generated by crates/board/build.rs\n");
    content.push_str("// DO NOT EDIT THIS FILE MANUALLY\n");
    content.push_str("//\n");
    content.push_str("// To regenerate types, run:\n");
    content.push_str("//   cargo build --package elizabeth-board --features typescript-export\n");
    content.push_str("//\n\n");

    content.push_str("// Re-export all generated types\n");
    for &type_name in board_protocol::codegen::exported_ts_type_names() {
        content.push_str(&format!("export * from './{type_name}';\n"));
    }

    fs::write(&index_file, content)?;
    println!("cargo:warning=generated TS index {:?}", &index_file);
    Ok(())
}
